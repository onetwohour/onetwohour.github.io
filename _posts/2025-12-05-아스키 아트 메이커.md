---
layout: post
title: "아스키 아트 메이커"
date: 2025-12-15
excerpt: "완벽한 아스키 아트를 만들어보자"
tag:
- 아스키 아트
- 메모
- C++
- OpenCV
- SIMD
comments: true
published: true
---

# [2025-12-15] 아스키 아트 메이커

---

반갑다.

금방 돌아오겠다 해놓고 유기한 사람이다.

변명은 하지 않겠다.

근데 갑자기 꽂힌 게 있다.

얼마전에 아스키 아트를 봤는데 나도 만들어 보고 싶었다.

근데 그냥 만들면 재미없고, 뭔가 좀 완벽한 아스키 아트를 만들어 보고 싶었다.

그래서 생각했다. 문자를 그리드로 나눠서, 각 그리드별로 밀도를 계산하고 그림을 그리면 좋지 않을까 하고.

쉽게 말하면 이렇다. `[` 와 `]`는 한 글자 내에서는 같은 밀도를 갖는다. 하지만 시각적으로는 분명한 차이가 있다. 이는 각 글자의 모양을 고려하지 않고 순수 밀도로만 측정하기 때문에 이런 문제가 발생한다.

여기서 한가지 아이디어를 추가해 보자. 글자를 그리드로 나눠서 밀도를 계산하면 밝기와 모양 둘 다 정밀하게 표현할 수 있지 않을까?

---

### 1. 접근 방식

기존의 방식이 픽셀의 평균 밝기를 구해서 `.,-~:;=!*#$@` 같은 룩업 테이블(LUT)에 매핑하는 방식이었다면, 이번엔 좀 더 하이-테크놀로지 방법을 쓰기로 했다.

1.  원본 이미지를 $16 \times 12$ 크기의 작은 그리드(Grid)로 쪼갠다.
2.  이 그리드 안의 픽셀 패턴을 비트마스크(Bitmask)로 딴다.
3.  우리가 가진 수천 개의 폰트 글자들도 똑같이 $16 \times 12$로 렌더링해서 비트마스크를 미리 따놓는다.
4.  원본의 패턴과 가장 유사한(비트 차이가 가장 적은) 글자를 찾아낸다.

이렇게 하면 단순히 '밝은 글자'가 아니라, '그 위치에 획이 있는 글자'를 찾을 수 있다.

### 2. 데이터 구조

$16 \times 12$ 픽셀은 총 192개 픽셀이다. 이걸 `uint64_t` 3개에 나눠 담으면 딱 떨어진다. ($64 \times 3 = 192$)

```cpp
struct PackedPattern {
    char32_t cp;
    uint64_t p1, p2, p3; // 192비트 패턴
    int density;         // 밀도(밝기)
};
```

이제 모든 유니코드 문자를 이 구조체로 변환해 둔다.

### 3. Hamming Distance

이제 입력 영상의 한 블록과 가장 닮은 글자를 찾아야 한다. 여기서 등장하는 것이 **Hamming Distance**다.

두 비트 패턴을 XOR 연산하면, 서로 다른 부분만 1로 남는다. 이 1의 개수(Popcount)를 세면 그게 바로 두 패턴의 차이다.

```cpp
// 대충 이런 느낌
uint64_t diff1 = input_p1 ^ font_p1;
uint64_t diff2 = input_p2 ^ font_p2;
uint64_t diff3 = input_p3 ^ font_p3;
int difference = popcount(diff1) + popcount(diff2) + popcount(diff3);
```

이 차이가 가장 작으면 그게 바로 내가 원한 '완벽한' 아스키 문자다.

### 4. 최적화

동영상은 초당 30\~60프레임이다. 프레임마다 수천 개의 그리드가 나오고, 각 그리드마다 수만 개의 글자와 비교해야 한다. 그냥 짜면 1프레임 렌더링하는데 1초 넘게 걸린다. 최적화가 필요하다.

**1) SIMD (AVX/SSE)**
픽셀 데이터를 비트로 변환할 때 루프 돌리면 느리다. 인텔 형님들이 만들어준 SIMD 명령어를 써서 16개 픽셀씩 한방에 처리한다. `_mm_movemask_epi8` 같은 걸 쓰면 좋다고 한다.

**2) 병렬 처리 (Parallel For)**
당연하지만 이런건 병렬이 필요하다. OpenCV의 `parallel_for_`를 써서 이미지의 각 행(Row)을 스레드별로 나눠서 처리했다.

**3) 룩업 테이블 & 버킷팅**
모든 글자를 다 뒤지면 느리다. 글자들을 미리 밀도(Density) 별로 분류(Bucket)해 둔다. 입력 그리드의 밝기가 100이라면, 밝기 85~115 사이의 글자들 중에서만 모양 비교를 수행한다. 탐색 범위를 확 줄일 수 있다.

### 5. 결과 코드

서론이 길었다. 코드는 아래와 같다.
C++17 이상, OpenCV 4.x가 필요하다. 윈도우와 리눅스 모두 돌아간다.

<details markdown="1">
  <summary><strong>전체 코드 보기</strong></summary>

```cpp
#define NOMINMAX

#include <iostream>
#include <vector>
#include <string>
#include <limits>
#include <thread>
#include <chrono>
#include <unordered_set>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <array>
#include <immintrin.h>

#include <opencv2/opencv.hpp>
#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/freetype.hpp>
#include <opencv2/core/ocl.hpp>

#ifdef _WIN32
#include <windows.h>
#include <intrin.h>
#include <conio.h>
#else
#include <x86intrin.h>
#include <termios.h>
#include <unistd.h>
#include <sys/ioctl.h>
#endif

using namespace cv;
using namespace std;

static inline bool is_surrogate(char32_t cp) {
    return (cp >= 0xD800 && cp <= 0xDFFF);
}

static inline bool is_combining(char32_t cp) {
    return (cp >= 0x0300 && cp <= 0x036F) ||
        (cp >= 0x1AB0 && cp <= 0x1AFF) ||
        (cp >= 0x1DC0 && cp <= 0x1DFF) ||
        (cp >= 0x20D0 && cp <= 0x20FF) ||
        (cp >= 0xFE20 && cp <= 0xFE2F);
}

static inline bool is_variation_selector(char32_t cp) {
    return (cp >= 0xFE00 && cp <= 0xFE0F) ||
        (cp >= 0xE0100 && cp <= 0xE01EF);
}

static inline bool is_emoji_like(char32_t cp) {
    if (cp == 0xFE0F) return true;
    if (cp >= 0x1F000 && cp <= 0x1FAFF) return true;
    if (cp >= 0x2600 && cp <= 0x27BF) return true;
    if (cp >= 0x2300 && cp <= 0x23FF) return true;
    if (cp >= 0xFE00 && cp <= 0xFE0F) return true;
    return false;
}

static inline bool is_bidi_or_invisible(char32_t cp) {
    if (cp == 0x200B || cp == 0x200C || cp == 0x200D) return true;
    if (cp == 0x2060) return true;
    if (cp >= 0x2066 && cp <= 0x2069) return true;
    if (cp >= 0x202A && cp <= 0x202E) return true;
    if (cp >= 0x200E && cp <= 0x200F) return true;
    return false;
}

static inline bool is_space_like(char32_t cp) {
    return (cp >= 0x2000 && cp <= 0x200A) ||
        cp == 0x202F || cp == 0x205F || cp == 0x3000;
}

static inline bool allow_cp(char32_t cp) {
    if (cp < 0x20) return false;
    if (is_surrogate(cp)) return false;
    if (is_combining(cp)) return false;
    if (is_variation_selector(cp)) return false;
    if (is_bidi_or_invisible(cp)) return false;
    if (is_space_like(cp)) return false;
    if (is_emoji_like(cp)) return false;
    return true;
}

static std::u32string build_charset_u32_massive() {
    std::u32string cs;
    cs.reserve(20000);

    auto add_range = [&](char32_t a, char32_t b, int step = 1) {
        if (step <= 0) return;
        if (a > b) return;
        for (uint32_t u = (uint32_t)a; u <= (uint32_t)b; u += (uint32_t)step) {
            char32_t cp = (char32_t)u;
            if (allow_cp(cp)) cs.push_back(cp);
            if (u > 0x10FFFFu - (uint32_t)step) break;
        }
    };

    add_range(0x20, 0x7E);
    add_range(0x00A1, 0x00FF);
    add_range(0x20A0, 0x20CF);
    add_range(0x2100, 0x214F);
    add_range(0x2190, 0x21FF);
    add_range(0x2200, 0x22FF);
    add_range(0x2300, 0x23FF);
    add_range(0x2460, 0x24FF);
    add_range(0x2500, 0x257F);
    add_range(0x2580, 0x259F);
    add_range(0x25A0, 0x25FF);
    add_range(0x27C0, 0x27EF);
    add_range(0x27F0, 0x27FF);
    add_range(0x2800, 0x28FF);
    add_range(0x2900, 0x297F);
    add_range(0x2A00, 0x2AFF);
    add_range(0x2B00, 0x2BFF);

    return cs;
}

const int GRID_W = 16;
const int GRID_H = 12;
const int TOTAL_PIXELS = GRID_W * GRID_H;

static inline uint32_t popcount64(uint64_t v) {
#if defined(_MSC_VER)
    return uint32_t(__popcnt64(v));
#else
    return uint32_t(__builtin_popcountll(v));
#endif
}

struct PackedPattern {
    char32_t cp;
    uint64_t p1, p2, p3;
    int density;
};

struct Key192 {
    uint64_t p1, p2, p3;
    bool operator==(const Key192& o) const noexcept {
        return p1 == o.p1 && p2 == o.p2 && p3 == o.p3;
    }
};

struct Key192Hash {
    size_t operator()(const Key192& k) const noexcept {
        size_t h1 = hash<uint64_t>{}(k.p1);
        size_t h2 = hash<uint64_t>{}(k.p2);
        size_t h3 = hash<uint64_t>{}(k.p3);
        size_t c = h1 ^ (h2 + 0x9e3779b97f4a7c15ULL + (h1 << 6) + (h1 >> 2));
        return c ^ (h3 + 0x9e3779b97f4a7c15ULL + (c << 6) + (c >> 2));
    }
};

struct Utf8Char {
    char bytes[4];
    uint8_t len;
};

static inline Utf8Char encode_utf8(char32_t cp) {
    Utf8Char u{};
    if (cp <= 0x7F) {
        u.bytes[0] = char(cp);
        u.len = 1;
    }
    else if (cp <= 0x7FF) {
        u.bytes[0] = char(0xC0 | (cp >> 6));
        u.bytes[1] = char(0x80 | (cp & 0x3F));
        u.len = 2;
    }
    else if (cp <= 0xFFFF) {
        u.bytes[0] = char(0xE0 | (cp >> 12));
        u.bytes[1] = char(0x80 | ((cp >> 6) & 0x3F));
        u.bytes[2] = char(0x80 | (cp & 0x3F));
        u.len = 3;
    }
    else {
        u.bytes[0] = char(0xF0 | (cp >> 18));
        u.bytes[1] = char(0x80 | ((cp >> 12) & 0x3F));
        u.bytes[2] = char(0x80 | ((cp >> 6) & 0x3F));
        u.bytes[3] = char(0x80 | (cp & 0x3F));
        u.len = 4;
    }
    return u;
}

static inline uint16_t row_mask_gt_u8_t(const uint8_t* p, __m128i t, __m128i sign) {
    __m128i v = _mm_loadu_si128((const __m128i*)p);
    v = _mm_xor_si128(v, sign);
    __m128i cmp = _mm_cmpgt_epi8(v, t);
    return uint16_t(_mm_movemask_epi8(cmp));
}

static inline void pack_template_simd_t(const uint8_t* base, int stride, __m128i t, __m128i sign,
    uint64_t& p1, uint64_t& p2, uint64_t& p3) {
    uint64_t a = 0, b = 0, c = 0;
    for (int y = 0; y < 4; ++y) a |= uint64_t(row_mask_gt_u8_t(base + y * stride, t, sign)) << (y * 16);
    base += 4 * stride;
    for (int y = 0; y < 4; ++y) b |= uint64_t(row_mask_gt_u8_t(base + y * stride, t, sign)) << (y * 16);
    base += 4 * stride;
    for (int y = 0; y < 4; ++y) c |= uint64_t(row_mask_gt_u8_t(base + y * stride, t, sign)) << (y * 16);
    p1 = a; p2 = b; p3 = c;
}

struct CandItem {
    uint64_t p1, p2, p3;
    uint16_t penalty;
    Utf8Char u8;
};

class PatternMatcher {
    vector<vector<PackedPattern>> buckets;
    array<int, 256> densFromBright{};
    array<vector<CandItem>, 256> cand;
    Ptr<freetype::FreeType2> ft2;
    char32_t blank = U' ';
    int minD = 0;
    int maxD = 0;

public:
    PatternMatcher(const string& ttf_path, const array<int, 256>& densLUT, int fontH = 16) {
        densFromBright = densLUT;
        buckets.resize(TOTAL_PIXELS + 1);

        ft2 = freetype::createFreeType2();
        ft2->loadFontData(ttf_path, 0);

        u32string charset = build_charset_u32_massive();
        charset.push_back(0x2588);

        Mat canvas(32, 32, CV_8UC1);
        unordered_set<Key192, Key192Hash> seen;

        for (char32_t cp : charset) {
            if (cp < 0x20 || (0xD800 <= cp && cp <= 0xDFFF)) continue;
            canvas.setTo(0);

            string s;
            {
                Utf8Char u = encode_utf8(cp);
                s.assign(u.bytes, u.bytes + u.len);
            }

            ft2->putText(canvas, s, { 2,24 }, fontH, Scalar(255), 1, LINE_AA, true);
            if (countNonZero(canvas) == 0) continue;

            Mat r;
            resize(canvas, r, { GRID_W, GRID_H }, 0, 0, INTER_AREA);

            uint64_t p1 = 0, p2 = 0, p3 = 0;
            int dens = 0;

            for (int y = 0; y < GRID_H; ++y) {
                const uint8_t* row = r.ptr<uint8_t>(y);
                for (int x = 0; x < GRID_W; ++x) {
                    int i = y * GRID_W + x;
                    if (row[x] > 128) {
                        if (i < 64) p1 |= 1ULL << i;
                        else if (i < 128) p2 |= 1ULL << (i - 64);
                        else p3 |= 1ULL << (i - 128);
                        ++dens;
                    }
                }
            }

            Key192 key{ p1,p2,p3 };
            if (seen.insert(key).second) buckets[dens].push_back({ cp,p1,p2,p3,dens });
        }

        buckets[0].push_back({ blank,0,0,0,0 });

        maxD = 0;
        for (int d = TOTAL_PIXELS; d >= 0; --d) {
            if (!buckets[d].empty()) { maxD = d; break; }
        }
        minD = 0;
        for (int d = 0; d <= TOTAL_PIXELS; ++d) {
            if (!buckets[d].empty()) { minD = d; break; }
        }

        for (int b = 0; b < 256; ++b) {
            int target = densFromBright[b];
            target = std::min(std::max(target, minD), maxD);

            int mn = max(0, target - 15);
            int mx = min(TOTAL_PIXELS, target + 15);

            auto& v = cand[b];
            size_t reserveCount = 0;
            for (int d = mn; d <= mx; ++d) reserveCount += buckets[d].size();
            v.reserve(reserveCount);

            for (int d = mn; d <= mx; ++d) {
                for (const auto& t : buckets[d]) {
                    CandItem ci;
                    ci.p1 = t.p1; ci.p2 = t.p2; ci.p3 = t.p3;
                    ci.penalty = uint16_t(abs(t.density - target) * 2);
                    ci.u8 = encode_utf8(t.cp);
                    v.push_back(ci);
                }
            }

            if (v.empty()) {
                for (int radius = 1; radius <= TOTAL_PIXELS; ++radius) {
                    int lo = target - radius;
                    int hi = target + radius;
                    if (lo >= 0 && !buckets[lo].empty()) {
                        for (const auto& t : buckets[lo]) {
                            CandItem ci;
                            ci.p1 = t.p1; ci.p2 = t.p2; ci.p3 = t.p3;
                            ci.penalty = uint16_t(abs(t.density - target) * 2);
                            ci.u8 = encode_utf8(t.cp);
                            v.push_back(ci);
                        }
                        break;
                    }
                    if (hi <= TOTAL_PIXELS && !buckets[hi].empty()) {
                        for (const auto& t : buckets[hi]) {
                            CandItem ci;
                            ci.p1 = t.p1; ci.p2 = t.p2; ci.p3 = t.p3;
                            ci.penalty = uint16_t(abs(t.density - target) * 2);
                            ci.u8 = encode_utf8(t.cp);
                            v.push_back(ci);
                        }
                        break;
                    }
                }
            }
        }
    }

    inline const CandItem* match(uint64_t p1, uint64_t p2, uint64_t p3, int brightness) const {
        const auto& v = cand[brightness];
        uint32_t best = numeric_limits<uint32_t>::max();
        const CandItem* bestItem = nullptr;

        for (const auto& t : v) {
            uint32_t diff = popcount64(p1 ^ t.p1);
            if (diff >= best) continue;

            diff += popcount64(p2 ^ t.p2);
            if (diff >= best) continue;

            diff += popcount64(p3 ^ t.p3);
            diff += t.penalty;

            if (diff < best) {
                best = diff;
                bestItem = &t;
                if (diff == 0) return bestItem;
            }
        }
        return bestItem;
    }
};

class ParallelRender : public ParallelLoopBody {
    const Mat& gray;
    const Mat& meanBright;
    const Mat& meanColor;
    const PatternMatcher& matcher;
    const array<string, 256>& dec;
    vector<string>& lines;
    int cols;
    bool use_color;

public:
    ParallelRender(const Mat& g, const Mat& mb, const Mat& mc,
        const PatternMatcher& m, int w, bool col,
        const array<string, 256>& d,
        vector<string>& buf)
        : gray(g), meanBright(mb), meanColor(mc), matcher(m), dec(d),
        lines(buf), cols(w), use_color(col) {
    }

    void operator()(const Range& range) const override {
        const int stride = int(gray.step);
        __m128i sign = _mm_set1_epi8(char(0x80));

        for (int y = range.start; y < range.end; ++y) {
            string& out = lines[y];
            out.clear();
            out.reserve(cols * (use_color ? 18 : 4));

            const uint8_t* mbRow = meanBright.ptr<uint8_t>(y);
            const Vec3b* mcRow = use_color ? meanColor.ptr<Vec3b>(y) : nullptr;

            const int y0 = y * GRID_H;
            const uint8_t* grayRow0 = gray.ptr<uint8_t>(y0);

            int lastR = -1, lastG = -1, lastB = -1;

            for (int x = 0; x < cols; ++x) {
                const int x0 = x * GRID_W;
                const uint8_t bright = mbRow[x];
                const uint8_t thr = uint8_t((bright >> 2) << 2);

                __m128i t = _mm_set1_epi8(char(thr ^ 0x80));

                uint64_t p1, p2, p3;
                const uint8_t* base = grayRow0 + x0;
                pack_template_simd_t(base, stride, t, sign, p1, p2, p3);

                if (use_color) {
                    const Vec3b c = mcRow[x];
                    const int b = c[0], g = c[1], r = c[2];
                    if (r != lastR || g != lastG || b != lastB) {
                        out.append("\033[38;2;");
                        out.append(dec[r]); out.push_back(';');
                        out.append(dec[g]); out.push_back(';');
                        out.append(dec[b]); out.push_back('m');
                        lastR = r; lastG = g; lastB = b;
                    }
                }

                const CandItem* item = matcher.match(p1, p2, p3, bright);
                if (item) out.append(item->u8.bytes, item->u8.bytes + item->u8.len);
                else out.push_back(' ');
            }

            if (use_color) out.append("\033[0m");
        }
    }
};

#ifdef _WIN32
static bool GetConsoleCellSize(int& outCols, int& outRows) {
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hOut == INVALID_HANDLE_VALUE) return false;

    CONSOLE_SCREEN_BUFFER_INFO csbi{};
    if (!GetConsoleScreenBufferInfo(hOut, &csbi)) return false;

    outCols = int(csbi.srWindow.Right - csbi.srWindow.Left + 1);
    outRows = int(csbi.srWindow.Bottom - csbi.srWindow.Top + 1);
    return (outCols > 0 && outRows > 0);
}
#else
static bool GetConsoleCellSize(int& outCols, int& outRows) {
    winsize ws{};
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) != 0) return false;
    outCols = int(ws.ws_col);
    outRows = int(ws.ws_row);
    return (outCols > 0 && outRows > 0);
}

struct TermRawGuard {
    termios oldt{};
    int oldFlags = -1;
    bool ok = false;

    TermRawGuard() {
        if (!isatty(STDIN_FILENO)) return;
        if (tcgetattr(STDIN_FILENO, &oldt) != 0) return;

        termios newt = oldt;
        newt.c_lflag &= ~(ICANON | ECHO);
        newt.c_iflag &= ~(IXON | ICRNL);
        newt.c_oflag &= ~(OPOST);
        newt.c_cc[VMIN] = 0;
        newt.c_cc[VTIME] = 0;

        if (tcsetattr(STDIN_FILENO, TCSANOW, &newt) != 0) return;

        oldFlags = fcntl(STDIN_FILENO, F_GETFL, 0);
        if (oldFlags != -1) {
            fcntl(STDIN_FILENO, F_SETFL, oldFlags | O_NONBLOCK);
        }

        ok = true;
    }

    ~TermRawGuard() {
        if (!ok) return;
        tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
        if (oldFlags != -1) {
            fcntl(STDIN_FILENO, F_SETFL, oldFlags);
        }
    }
};

static inline bool kb_hit_unix() {
    int n = 0;
    if (ioctl(STDIN_FILENO, FIONREAD, &n) == -1) return false;
    return n > 0;
}

static inline int get_ch_unix() {
    unsigned char c;
    ssize_t r = read(STDIN_FILENO, &c, 1);
    if (r == 1) return (int)c;
    return -1;
}

static inline void drain_esc_sequence_unix() {
    for (int i = 0; i < 8; ++i) {
        if (!kb_hit_unix()) break;
        int c = get_ch_unix();
        if (c < 0) break;
    }
}
#endif

struct CursorGuard {
    ~CursorGuard() { std::cout << "\033[?25h\033[0m" << std::flush; }
};

int main(int argc, char** argv) {
    cv::ocl::setUseOpenCL(false);
    cv::setUseOptimized(true);
    cv::setNumThreads(0);

    CursorGuard _cursorGuard;

#ifndef _WIN32
    TermRawGuard _rawGuard;
#endif

#ifdef _WIN32
    SetConsoleOutputCP(65001);
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD mode = 0;
    if (GetConsoleMode(hOut, &mode)) {
        mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
        SetConsoleMode(hOut, mode);
    }
#endif

    cout << "\033[?25l";

    string video = (argc > 1) ? argv[1] : "video.mp4";
    string ttf = (argc > 2) ? argv[2] : "C:/Windows/Fonts/consola.ttf";

    VideoCapture cap(video);
    if (!cap.isOpened()) {
        cap.open(0);
        if (!cap.isOpened()) return -1;
    }

    double fps = cap.get(CAP_PROP_FPS);
    if (!(fps > 1 && fps < 240)) fps = 30.0;
    auto budget = chrono::duration<double>(1.0 / fps);

    array<string, 256> dec;
    for (int i = 0; i < 256; ++i) dec[i] = to_string(i);

    array<int, 256> densLUT;
    for (int b = 0; b < 256; ++b) {
        float n = b / 255.0f;
        int d = int(pow(n, 2.2f) * TOTAL_PIXELS);
        if (b >= 8 && d < 1) d = 1;
        if (b >= 16 && d < 2) d = 2;
        densLUT[b] = d;
    }

    PatternMatcher matcher(ttf, densLUT, 16);
    Ptr<CLAHE> clahe = createCLAHE(1.1, { 8,8 });

    Mat frame;
    Mat frameTgt, grayTgt, fil, edge;
    Mat dx, dy;
    Mat meanBright, meanColor;

    Mat kernel = (Mat_<float>(3, 3) << 0, -1, 0, -1, 5, -1, 0, -1, 0);

    int lastRows = -1;
    int lastCols = -1;
    int prevConCols = -1;
    int prevConRows = -1;
    Size lastTgt(-1, -1);
    vector<string> buffer;
    string output;
    bool colorMode = true;

    float fontScale = 0.55f;
    auto lastTime = chrono::steady_clock::now();
    double currentFps = 0.0;

    bool isScaleChanged = false;

    while (true) {
        auto t0 = chrono::steady_clock::now();
        isScaleChanged = false;

#ifdef _WIN32
        if (_kbhit()) {
            int ch = _getch();
            if (ch == 'c' || ch == 'C') colorMode = !colorMode;
            else if (ch == 27) break;

            if (ch == ',' || ch == '<') {
                fontScale += 0.01f;
                isScaleChanged = true;
            }
            else if (ch == '.' || ch == '>') {
                fontScale = max(0.05f, fontScale - 0.01f);
                isScaleChanged = true;
            }
            else if (ch == 'r' || ch == 'R') {
                fontScale = 0.55f;
                isScaleChanged = true;
            }
        }
#else
        while (kb_hit_unix()) {
            int ch = get_ch_unix();
            if (ch < 0) break;

            if (ch == 27) {
                if (kb_hit_unix()) {
                    drain_esc_sequence_unix();
                    continue;
                }
                goto end_loop;
            }

            if (ch == 'c' || ch == 'C') colorMode = !colorMode;
            else if (ch == ',' || ch == '<') { fontScale += 0.01f; isScaleChanged = true; }
            else if (ch == '.' || ch == '>') { fontScale = max(0.05f, fontScale - 0.01f); isScaleChanged = true; }
            else if (ch == 'r' || ch == 'R') { fontScale = 0.55f; isScaleChanged = true; }
        }
#endif

        if (!cap.read(frame) || frame.empty()) break;

        int conCols = 0, conRows = 0;
        if (!GetConsoleCellSize(conCols, conRows)) {
            conCols = 240;
            conRows = 60;
        }

        if (conCols != prevConCols || conRows != prevConRows || isScaleChanged) {
            if (conCols != prevConCols || conRows != prevConRows) {
                prevConCols = conCols;
                prevConRows = conRows;
            }

            fwrite("\033[3J\033[2J\033[H", 1, 12, stdout);
            fflush(stdout);

            lastTgt = Size(-1, -1);
            lastRows = -1;
            lastCols = -1;
        }

        int usableCols = max(1, conCols);
        int usableRows = max(1, conRows - 1);

        int videoMaxCols = usableCols;
        int videoMaxRows = usableRows;

        float aspect = float(frame.rows) / float(frame.cols);
        float charAspect = aspect * fontScale;
        if (charAspect < 1e-6f) charAspect = 1e-6f;

        int rowsMax = min(usableRows, videoMaxRows);
        int colsByHeight = int(floor(double(rowsMax) / double(charAspect)));
        colsByHeight = max(1, colsByHeight);

        int cols = min({ usableCols, videoMaxCols, colsByHeight });
        int rows = int(floor(double(cols) * double(charAspect)));
        rows = max(1, min(rows, rowsMax));

        Size tgt(cols * GRID_W, rows * GRID_H);

        if (tgt != lastTgt) {
            frameTgt.create(tgt, CV_8UC3);
            grayTgt.create(tgt, CV_8UC1);
            fil.create(tgt, CV_8UC1);
            edge.create(tgt, CV_8UC1);
            dx.create(tgt, CV_16S);
            dy.create(tgt, CV_16S);
            lastTgt = tgt;
        }

        if (rows != lastRows) {
            buffer.assign(rows, string());
            lastRows = rows;
        }
        if (cols != lastCols) {
            lastCols = cols;
        }

        resize(frame, frameTgt, tgt, 0, 0, INTER_LINEAR);
        cvtColor(frameTgt, grayTgt, COLOR_BGR2GRAY);
        clahe->apply(grayTgt, grayTgt);

        Sobel(grayTgt, dx, CV_16S, 1, 0, 1);
        Sobel(grayTgt, dy, CV_16S, 0, 1, 1);
        convertScaleAbs(dx, dx);
        convertScaleAbs(dy, dy);

        addWeighted(dx, 0.5, dy, 0.5, 0, edge);
        addWeighted(grayTgt, 0.7, edge, 0.5, 0, grayTgt);

        filter2D(grayTgt, fil, -1, kernel);

        meanBright.create(rows, cols, CV_8UC1);
        resize(fil, meanBright, Size(cols, rows), 0, 0, INTER_AREA);

        if (colorMode) {
            meanColor.create(rows, cols, CV_8UC3);
            resize(frameTgt, meanColor, Size(cols, rows), 0, 0, INTER_AREA);
        }
        else {
            meanColor.release();
        }

        parallel_for_(Range(0, rows), ParallelRender(fil, meanBright, meanColor, matcher,
            cols, colorMode, dec, buffer));

        output.clear();
        output.reserve(size_t(cols) * size_t(rows) * (colorMode ? 18 : 4) + 256);

        output.append("\033[H");

        char statusBuf[128];
        snprintf(statusBuf, sizeof(statusBuf),
            "\033[K[FPS: %.1f] [Scale: %.2f] [Color: %s] (<: Scale+, >: Scale-, C: Color, R: Reset, ESC: Quit)\n",
            currentFps, fontScale, colorMode ? "ON" : "OFF");

        if (colorMode) output.append("\033[37m");
        output.append(statusBuf);
        if (!colorMode) output.append("\033[0m");

        for (const auto& s : buffer) {
            output.append(s);
            output.push_back('\n');
        }

        fwrite(output.c_str(), 1, output.size(), stdout);

        auto t1 = chrono::steady_clock::now();
        auto dt = t1 - t0;

        currentFps = 1.0 / chrono::duration<double>(t1 - lastTime).count();
        lastTime = t1;

        if (dt < budget) this_thread::sleep_for(budget - dt);
    }

#ifndef _WIN32
    end_loop :
#endif
    return 0;
}
```

</details>

결과는 이렇다.

<a href="../images/ascii.gif" style="display:inline-block; align:center;">
  <img src="../images/ascii.gif" style="display:block; margin:0 auto;">
</a>

<a href="../images/ascii2.gif" style="display:inline-block; align:center;">
  <img src="../images/ascii2.gif" style="display:block; margin:0 auto;">
</a>

C를 누르면 컬러-흑백 전환이 가능하다. 화면 크기를 조절하면 알아서 해상도도 조절된다.

문제가 있다면 해상도가 높을수록 느려진다는 거 정도. 근데 뭐 당연한거 아닌가?

다른 문제가 있다면 전각 문자는 안된다는 거다. 한글이나 한자같은걸 추가하면 글자 크기가 달라져서 결과가 괴상해진다. 얌전히 영어나 쓰자.

비디오가 없으면 웹캠을 쓸 수 있다. 은근 재밌다.

그래서 뭐... 모양이 잘 보존되냐 하면 그런것 같긴 하다. 근데 비교를 안해봐서 얼마나 좋은지는 모르겠다. 필요한 사람이 알아서 하겠지... 

이걸로 뭘 할수 있냐 하면... 어... 비디오를 텍스트 스트림으로 보낼 수 있다 정도? 압축하거나 보안이 중요하면 잘 써먹을수도 있을것 같긴 한데 그럴거면 다른 방법이 있지 않을까.

